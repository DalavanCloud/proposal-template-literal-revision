<!doctype html>

<meta charset="utf8">
<link rel="stylesheet" href="ecmarkup.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="ecmarkup.js"></script>
<pre class=metadata>
title: Template LIteral revision
status: proposal
stage: 1
contributors: Tim Disney
toc: true
</pre>


<emu-intro>
  <h1>Introduction</h1>

  Template literals should allow the embedding of languages (DSLs etc.). But restrictions on escape sequences make this problematic.

  For example, consider making a latex processor with templates:
  <pre><code class="javascript">
    function latex(strings) {
      // ...
    }

    let document = latex`
    \newcommand{\fun}{\textbf{Fun!}}  // works just fine
    \newcommand{\unicode}{\textbf{Unicode!}} // Illegal token!
    \newcommand{\xerxes}{\textbf{King!}} // Illegal token!

    Breve over the h goes \u{h}ere // Illegal token!
    `
  </code></pre>

  The problem here is that `\u` is the start of a unicode escape, but ES grammar forces it to be of the form `\u00FF` or `\u{42}`
  and considers the token `\unicode` illegal.
  Similarly `\x` is the start of a hex escape like `\xFF` but `\xerxes` is illegal. Octal literal escapes have the same problem; `\0100` is illegal.

  <h2>Proposal Overview</h2>

  Remove the restriction on escape sequences.

  Lifting the restriction raises the question of how to handle cooked template values that contain illegal escape sequences. Currently, cooked template values are supposed to replace escape sequences with the "Unicode code point represented by the escape sequence" but this can't happen if the escape sequence is not valid.

  The proposed solution is to set the cooked value to `undefined` for template values that contain illegal escape sequences. The raw value is still accessible via `.raw` so embedded DSLs that might contain `undefined` cooked values can just use the raw string:

  <pre><code class="javascript">
    function tag(strs) {
      strs[0] === undefined
      strs.raw[0] === "\\unicode and \\u{55}";
    }
    tag`\unicode and \u{55}`
  </code></pre>

  This loosening of the escape sequence restriction only applies to tagged template literals; untagged templates still throw an early error for invalid escape sequences:

  <pre><code class="javascript">
    let bad = `bad escape sequence: \unicode`; // throws early error
  </code><pre>

</emu-intro>


<style>
  tr.ins, li.ins { background-color: #e0f8e0; text-decoration: none; border-bottom: 1px solid #396; }
  tr.ins > td > ins, li.ins > ins { border-bottom: 0; }
</style>
